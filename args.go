package main

import (
	"encoding/json"
	"fmt"
	"os"
	"strconv"

	"github.com/jinzhu/gorm"
	uuid "github.com/satori/go.uuid"
)

// CliArgs is the arguments for the program.
type CliArgs struct {
	dump               bool
	dumpFile           string
	slurp              bool
	slurpFile          string
	register           bool
	configPath         string
	keyFolder          string
	registerKey        string
	registerPowerLevel int
	promote            bool
	promoteKey         string
	promotePowerLevel  int
}

func getArgs() CliArgs {
	// get cli rawArgs
	rawArgs := os.Args[1:]
	cliArgs := CliArgs{}

	for i, arg := range rawArgs {
		if arg == "--help" {
			fmt.Println(`
--keys       /path/to/keyfolder         The path that your key folder is in. If it is not present, one will be generated.
--config     /path/to/config.json       The path that your config file is in. If it is not present, the default config will be written here.
--register   PubKey PowerLevel          Registers a user manually on the server. with a given public key and power level. Will print the user details.
--port       number                     Sets the port number to listen on.
--backup     /path/to/file.json         Dumps the database into JSON for import into another Vex Server.
--import     /path/to/file.json         Imports the JSON dump generated by another Vex Server.
			`)
			os.Exit(0)
		}
		if arg == "--dump" {
			cliArgs.dump = true
			if len(rawArgs) > i+1 {
				cliArgs.dumpFile = rawArgs[i+1]
			} else {
				log.Fatal("File path argument is required for dump. --dump /path/to/dump.json")
			}
		}

		if arg == "--import" {
			cliArgs.slurp = true

			if len(rawArgs) > i+1 {
				cliArgs.slurpFile = rawArgs[i+1]
			} else {
				log.Fatal("File argument is required for import. --import /path/to/dump.json")
			}
		}

		if arg == "--register" {
			if len(rawArgs) > i+2 {
				cliArgs.register = true
				cliArgs.registerKey = rawArgs[i+1]
				registerPowerLevel, err := strconv.Atoi(rawArgs[i+2])
				check(err)
				cliArgs.registerPowerLevel = registerPowerLevel
			} else {
				log.Fatal("Register argument requires a public key and powerlevel argument. --register pubkey 100")
			}
		}

		if arg == "--promote" {
			if len(rawArgs) > i+2 {
				cliArgs.promote = true
				cliArgs.promoteKey = rawArgs[i+1]
				promotePowerLevel, err := strconv.Atoi(rawArgs[i+2])
				check(err)
				cliArgs.promotePowerLevel = promotePowerLevel
			} else {
				log.Fatal("Register argument requires a public key and powerlevel argument. --register pubkey 100")
			}
		}

		if arg == "--config" {
			if len(rawArgs) > i+1 {
				cliArgs.configPath = rawArgs[i+1]
			} else {
				log.Fatal("File argument is required for config. --config /path/to/config.json")
			}
		}

		if arg == "--keys" {
			if len(rawArgs) > i+1 {
				cliArgs.keyFolder = rawArgs[i+1]
			} else {
				log.Fatal("File argument is required for key folder. --config /path/to/keyfolder")
			}
		}
	}
	return cliArgs
}

func runUtils(cliArgs CliArgs, db *gorm.DB) {
	if cliArgs.promote {
		log.Notice("Promoting user with pubkey " + cliArgs.registerKey)
		var promoteClient Client
		db.First(&promoteClient, "pub_key = ?", cliArgs.promoteKey)

		if promoteClient.ID == 0 {
			log.Fatal("Pubkey not found in database.")
		}

		promoteClient.PowerLevel = cliArgs.promotePowerLevel
		db.Save(&promoteClient)
		log.Notice("User promoted to power level " + strconv.Itoa(cliArgs.promotePowerLevel))
		os.Exit(0)
	}

	if cliArgs.register {
		log.Notice("Registering user with pubkey " + cliArgs.registerKey)
		newID := uuid.NewV4()
		db.Create(&Client{UserID: newID, PubKey: cliArgs.registerKey, Username: "Anonymous", PowerLevel: cliArgs.registerPowerLevel, Banned: false})
		log.Notice("User created with power level " + strconv.Itoa(cliArgs.registerPowerLevel) + ", userID is " + newID.String())
		os.Exit(0)
	}

	if cliArgs.dump {
		log.Notice("Dumping backup data!")

		dump := Dump{}

		db.Find(&dump.Clients)
		db.Find(&dump.ChannelPermissions)
		db.Find(&dump.Chats)
		db.Find(&dump.Channels)

		writeJSONFile(cliArgs.dumpFile, dump)
		log.Notice("Backup completed, saved to " + cliArgs.dumpFile)
		os.Exit(0)
	}

	if cliArgs.slurp {
		log.Notice("Importing dump data from " + cliArgs.slurpFile)
		jsonBytes := readJSONFile(cliArgs.slurpFile)

		var slurpData Dump
		json.Unmarshal(jsonBytes, &slurpData)

		for _, client := range slurpData.Clients {
			db.Create(&client)
		}

		for _, channel := range slurpData.Channels {
			db.Create(&channel)
		}

		for _, channelPerm := range slurpData.ChannelPermissions {
			db.Create(&channelPerm)
		}

		for _, Chat := range slurpData.Chats {
			db.Create(&Chat)
		}

		log.Notice("Import complete!")
		os.Exit(0)
	}
}
